package me.saket.telephoto.subsamplingimage.internal

import android.graphics.BitmapFactory
import android.graphics.BitmapRegionDecoder
import android.os.Build
import androidx.compose.ui.graphics.ImageBitmap
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.toAndroidColorSpace
import androidx.compose.ui.graphics.toAndroidRect
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.IntRect
import androidx.compose.ui.unit.IntSize
import androidx.tracing.trace
import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.ExecutorCoroutineDispatcher
import kotlinx.coroutines.newSingleThreadContext
import kotlinx.coroutines.withContext
import me.saket.telephoto.subsamplingimage.ImageBitmapOptions
import me.saket.telephoto.subsamplingimage.RotatedImageBitmap
import me.saket.telephoto.subsamplingimage.SubSamplingImageSource
import me.saket.telephoto.subsamplingimage.internal.ExifMetadata.ImageOrientation
import me.saket.telephoto.subsamplingimage.toAndroidConfig

/** Bitmap decoder backed by Android's [BitmapRegionDecoder]. */
internal class AndroidImageRegionDecoder private constructor(
  private val imageSource: SubSamplingImageSource,
  private val imageOptions: ImageBitmapOptions,
  private val decoder: BitmapRegionDecoder,
  private val exif: ExifMetadata,
  private val dispatcher: ExecutorCoroutineDispatcher,
) : ImageRegionDecoder {

  override val imageSize: IntSize get() = decoder.size()
  override val imageOrientation: ImageOrientation get() = exif.orientation

  override suspend fun decodeRegion(region: ImageRegionTile): ImageBitmap {
    val options = BitmapFactory.Options().apply {
      inSampleSize = region.sampleSize.size
      inPreferredConfig = imageOptions.config.toAndroidConfig()
      if (Build.VERSION.SDK_INT >= 26) {
        inPreferredColorSpace = imageOptions.colorSpace?.toAndroidColorSpace()
      }
    }

    val bounds = region.bounds.rotateBy(
      // Rotation of images is transparent to consumers of ImageRegionDecoder.
      // When tiles are generated by SubSamplingImage, it assumes that the image is
      // already in the correct orientation. To counter this, rotate the bounds in
      // anticlockwise direction to get the bounds in the original non-rotated image.
      degrees = -exif.orientation.degrees,
      unRotatedParent = IntRect(offset = IntOffset.Zero, size = imageSize)
    )

    val bitmap = withContext(dispatcher) {
      trace("decodeRegion") {
        decoder.decodeRegion(bounds.toAndroidRect(), options)?.asImageBitmap()
      }
    }
    if (bitmap != null) {
      return RotatedImageBitmap(
        delegate = bitmap,
        orientation = exif.orientation,
      )
    } else {
      error("BitmapRegionDecoder returned a null bitmap. Image format may not be supported: $imageSource.")
    }
  }

  override fun close() {
    // Previous versions of telephoto recycled the dispatcher as well, but this was later removed
    // after discovering that close() and decodeRegion() could be called from different threads,
    // potentially causing a race condition. If a zoomable image is disposed while it was still
    // decoding regions, the underlying decoder will remain in memory for a bit longer until GC
    // kicks in. I think that is okay as its memory usage would be similar to displaying multiple
    // _active_ images in a pager, each allocating a decoder.
    dispatcher.close()
  }

  private fun BitmapRegionDecoder.size(): IntSize {
    val shouldFlip = when (exif.orientation) {
      ImageOrientation.Orientation90,
      ImageOrientation.Orientation270 -> true
      else -> false
    }

    return IntSize(
      width = if (shouldFlip) height else width,
      height = if (shouldFlip) width else height,
    )
  }

  companion object {
    @OptIn(DelicateCoroutinesApi::class)
    val Factory = ImageRegionDecoder.Factory { params ->
      val dispatcher = newSingleThreadContext("AndroidImageRegionDecoder")

      AndroidImageRegionDecoder(
        imageSource = params.imageSource,
        imageOptions = params.imageOptions,
        decoder = withContext(dispatcher) {
          params.imageSource.decoder(params.context)
        },
        exif = params.exif,
        dispatcher = dispatcher,
      )
    }
  }
}
