{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Designing a cohesive media experience for Android can be a lot of work. Telephoto aims to make that easier by offering some building blocks for Compose UI.</p>"},{"location":"#zoomable-image","title":"Zoomable Image","text":"<p>Drop-in replacement for <code>Image()</code> composables featuring support for pan &amp; zoom gestures and automatic sub\u2011sampling of large images that'd otherwise not fit into memory.</p>"},{"location":"#modifierzoomable","title":"Modifier.zoomable()","text":"<p><code>ZoomableImage</code>'s gesture detector, packaged as a standalone <code>Modifier</code> that can be used with non-image composables.</p>"},{"location":"releasing/","title":"Release checklist","text":""},{"location":"releasing/#release-checklist","title":"Release checklist","text":"<ul> <li>[ ] Check that tests have passed on CI.</li> <li>[ ] Run manual test cases that are difficult to automate:</li> <li>[ ] Fling animations can be interrupted by pressing anywhere.</li> <li>[ ] Double-click-to-zoom animations can be interrupted only by starting another swipe gesture.</li> <li>[ ] Images that use a placeholder play a cross-fade animation when the image is loaded.</li> <li>[ ] Change version name from SNAPSHOT to an actual name.</li> <li>[ ] Update project website with:<ul> <li>[ ] new version\u2019s maven address</li> <li>[ ] new APIs</li> </ul> </li> <li>[ ] Commit <code>Prepare to release vX.X.X</code>. Do not push yet.</li> <li>[ ] Upload archives to maven.   <code>g clean publish --no-parallel --no-daemon</code></li> <li>[ ] Wait for artifacts to be available.   <code>dependency-watch await me.saket.telephoto:zoomable:{version}</code></li> <li>[ ] Ensure that the release is available on maven by using it in <code>:sample</code></li> <li>[ ] Check that the library sources were correctly available.</li> <li>[ ] Run the sample app and perform sanity tests.</li> <li>[ ] Push commit.</li> <li>[ ] Generate a sample APK.</li> <li>[ ] Draft a changelog.</li> <li>[ ] Make a release on Github.</li> <li>[ ] Push a new commit <code>Prepare next development version</code> by bumping version and changing library version to SNAPSHOT.</li> </ul>"},{"location":"zoomable/","title":"Overview","text":""},{"location":"zoomable/#modifierzoomable","title":"Modifier.zoomable()","text":"<p>A <code>Modifier</code> for handling pan &amp; zoom gestures, designed to be shared across all your media composables so that your users can use the same familiar gestures throughout your app. It offers,</p> <ul> <li>Pinch to zoom and flings</li> <li>Double click to zoom</li> <li>Single finger zoom (double click and hold)</li> <li>Haptic feedback for over/under zoom</li> <li>Compatibility with nested scrolling</li> <li>Click listeners</li> <li>Keyboard and mouse shortcuts</li> </ul>"},{"location":"zoomable/#installation","title":"Installation","text":"<pre><code>implementation(\"me.saket.telephoto:zoomable:0.13.0\")\n</code></pre> <pre><code>Box(\nModifier\n.size(200.dp)\n.zoomable(rememberZoomableState())\n.background(\nbrush = Brush.linearGradient(listOf(Color.Cyan, Color.Blue)),\nshape = RoundedCornerShape(4.dp)\n)\n)\n</code></pre> <p>While <code>Modifier.zoomable()</code> was primarily written with images &amp; videos in mind, it can be used for anything such as text, canvas drawings, etc.</p>"},{"location":"zoomable/#edge-detection","title":"Edge detection","text":"Without edge detection With edge detection <p>For preventing your content from over-zooming or over-panning, <code>Modifier.zoomable()</code> will use your content's layout size by default. This is good enough for composables that fill every pixel of their drawing space.</p> <p>For richer content such as an <code>Image()</code> whose visual size may not always match its layout size, <code>Modifier.zoomable()</code> will need your assistance.</p> <pre><code>val state = rememberZoomableState()\nval painter = resourcePainter(R.drawable.example)\nLaunchedEffect(painter.intrinsicSize) {\nstate.setContentLocation(\nZoomableContentLocation.scaledInsideAndCenterAligned(painter.intrinsicSize)\n)\n}\nImage(\nmodifier = Modifier\n.fillMaxSize()\n.background(Color.Orange)\n.zoomable(state),\npainter = painter,\ncontentDescription = \u2026,\ncontentScale = ContentScale.Inside,\nalignment = Alignment.Center,\n)\n</code></pre>"},{"location":"zoomable/#click-listeners","title":"Click listeners","text":"<p>For detecting double clicks, <code>Modifier.zoomable()</code> consumes all tap gestures making it incompatible with <code>Modifier.clickable()</code> and <code>Modifier.combinedClickable()</code>. As an alternative, its <code>onClick</code> and <code>onLongClick</code> parameters can be used.</p> <pre><code>Modifier.zoomable(\nstate = rememberZoomableState(),\nonClick = { \u2026 },\nonLongClick = { \u2026 },\n)\n</code></pre> <p>The default behavior of toggling between minimum and maximum zoom levels on double-clicks can be overridden by using the <code>onDoubleClick</code> parameter:</p> <pre><code>Modifier.zoomable(\nonDoubleClick = { state, centroid -&gt; \u2026 },\n)\n</code></pre>"},{"location":"zoomable/#applying-gesture-transformations","title":"Applying gesture transformations","text":"<p>When pan &amp; zoom gestures are received, <code>Modifier.zoomable()</code> automatically applies their resulting <code>scale</code> and <code>translation</code> onto your content using <code>Modifier.graphicsLayer()</code>. </p> <p>This can be disabled if your content prefers applying the transformations in a bespoke manner.</p> <pre><code>val state = rememberZoomableState(\nautoApplyTransformations = false\n)\nText(\nmodifier = Modifier\n.fillMaxSize()\n.zoomable(state),\ntext = \"Nicolas Cage\",\nstyle = state.contentTransformation.let {\nval weightMultiplier = if (it.isUnspecified) 1f else it.scale.scaleX\nTextStyle(\nfontSize = 36.sp,\nfontWeight = FontWeight(400 * weightMultiplier),\n)\n}\n)\n</code></pre>"},{"location":"zoomable/#keyboard-shortcuts","title":"Keyboard shortcuts","text":"<p><code>ZoomableImage()</code> can observe keyboard and mouse shortcuts for panning and zooming when it is focused, either by the user or using a <code>FocusRequester</code>:</p> <pre><code>val focusRequester = remember { FocusRequester() }\nLaunchedEffect(Unit) {\n// Automatically request focus when the image is displayed. This assumes there \n// is only one zoomable image present in the hierarchy. If you're displaying \n// multiple images in a pager, apply this only for the active page.  \nfocusRequester.requestFocus()\n}\nBox(\nModifier\n.focusRequester(focusRequester)\n.zoomable(),\n)\n</code></pre> <p>By default, the following shortcuts are recognized. These can be customized (or disabled) by passing a custom <code>HardwareShortcutsSpec</code> to <code>rememberZoomableState()</code>.</p> Android Desktop Zoom in <code>Control</code> + <code>=</code> <code>Meta</code> + <code>=</code> Zoom out <code>Control</code> + <code>-</code> <code>Meta</code> + <code>-</code> Pan Arrow keys Arrow keys Extra pan <code>Alt</code> + arrow keys <code>Option</code> + arrow keys"},{"location":"zoomable/recipes/","title":"Recipes","text":""},{"location":"zoomable/recipes/#observing-pan-zoom","title":"Observing pan &amp; zoom","text":"<pre><code>val state = rememberZoomableState()\nBox(\nModifier.zoomable(state)\n)\nLaunchedEffect(state.contentTransformation) {\nprintln(\"Pan = ${state.contentTransformation.offset}\")\nprintln(\"Zoom = ${state.contentTransformation.scale}\")\nprintln(\"Zoom fraction = ${state.zoomFraction}\")\n}\n// Example use case: Hide system bars when image is zoomed in.\nval systemUi = rememberSystemUiController()\nval isZoomedOut = (zoomState.zoomFraction ?: 0f) &lt; 0.1f\nLaunchedEffect(isZoomedOut) {\nsystemUi.isSystemBarsVisible = isZoomedOut\n}\n</code></pre>"},{"location":"zoomable/recipes/#controlling-pan-zoom","title":"Controlling pan &amp; zoom","text":"<pre><code>val state = rememberZoomableState()\nBox(\nModifier.zoomable(state)\n)\nButton(onClick = { state.zoomBy(zoomFactor = 1.2f) }) {\nText(\"+\")\n}\nButton(onClick = { state.zoomBy(zoomFactor = 1 / 1.2f) }) {\nText(\"-\")\n}\nButton(onClick = { state.panBy(offset = 50.dp) }) {\nText(\"&gt;\")\n}\nButton(onClick = { state.panBy(offset = -50.dp) }) {\nText(\"&lt;\")\n}\n</code></pre>"},{"location":"zoomable/recipes/#resetting-zoom","title":"Resetting zoom","text":"<p><code>Modifier.zoomable()</code> will automatically retain its pan &amp; zoom across state restorations. You may want to prevent this in lazy layouts such as a <code>Pager()</code>, where each page is restored every time it becomes visible. </p> <pre><code>val pagerState = rememberPagerState()\nHorizontalPager(\nstate = pagerState,\npageCount = 3,\n) { pageNum -&gt;\nval zoomableState = rememberZoomableState()\nZoomableContent(\nstate = zoomableState\n)\nif (pagerState.settledPage != pageNum) {\n// Page is now off-screen. Prevent restoration of \n// current zoom when this page becomes visible again.\nLaunchedEffect(Unit) {\nzoomableState.resetZoom(animationSpec = SnapSpec())\n}\n}\n}\n</code></pre> <p>Warning</p> <p>A bug in <code>Pager()</code> previously caused <code>settledPage</code> to reset to <code>0</code> upon state restoration. This issue has been resolved in <code>androidx.compose.foundation:foundation:1.5.0-alpha02</code>.</p>"},{"location":"zoomableimage/","title":"Overview","text":""},{"location":"zoomableimage/#zoomable-image","title":"Zoomable Image","text":"<p>A drop-in replacement for async <code>Image()</code> composables featuring support for pan &amp; zoom gestures and automatic sub-sampling of large images. This ensures that images maintain their intricate details even when fully zoomed in, without causing any <code>OutOfMemory</code> exceptions. </p> <p>Features</p> <ul> <li>Sub-sampling of bitmaps</li> <li>Pinch to zoom and flings</li> <li>Double click to zoom</li> <li>Single finger zoom (double click and hold)</li> <li>Haptic feedback for over/under zoom</li> <li>Compatibility with nested scrolling</li> <li>Click listeners</li> <li>Keyboard and mouse shortcuts</li> </ul>"},{"location":"zoomableimage/#installation","title":"Installation","text":"CoilGlide <pre><code>implementation(\"me.saket.telephoto:zoomable-image-coil:0.13.0\")\n</code></pre> <pre><code>implementation(\"me.saket.telephoto:zoomable-image-glide:0.13.0\")\n</code></pre> CoilGlide <pre><code>- AsyncImage(\n+ ZoomableAsyncImage(\n   model = \"https://example.com/image.jpg\",\n    contentDescription = \u2026\n  )\n</code></pre> <pre><code>- GlideImage(\n+ ZoomableGlideImage(\n   model = \"https://example.com/image.jpg\",\n    contentDescription = \u2026\n  )\n</code></pre>"},{"location":"zoomableimage/#image-requests","title":"Image requests","text":"<p>For complex scenarios, <code>ZoomableImage</code> can also take full image requests: </p> CoilGlide <pre><code>ZoomableAsyncImage(\nmodel = ImageRequest.Builder(LocalContext.current)\n.data(\"https://example.com/image.jpg\")\n.listener(\nonSuccess = { \u2026 },\nonError = { \u2026 },\n)\n.crossfade(1_000)\n.memoryCachePolicy(CachePolicy.DISABLED)\n.build(),\nimageLoader = LocalContext.current.imageLoader, // Optional.\ncontentDescription = \u2026\n)\n</code></pre> <pre><code>ZoomableGlideImage(\nmodel = \"https://example.com/image.jpg\",\ncontentDescription = \u2026\n) {\nit.addListener(object : RequestListener&lt;Drawable&gt; {\noverride fun onResourceReady(\u2026): Boolean = TODO()\noverride fun onLoadFailed(\u2026): Boolean = TODO()\n})\n.transition(withCrossFade(1_000))\n.skipMemoryCache(true)\n.disallowHardwareConfig()\n.timeout(30_000),\n}\n</code></pre>"},{"location":"zoomableimage/#placeholders","title":"Placeholders","text":"<p>If your images are available in multiple resolutions, <code>telephoto</code> highly recommends using their lower resolutions as placeholders while their full quality equivalents are loaded in the background.</p> <p>When combined with a cross-fade transition, <code>ZoomableImage</code> will smoothly swap out placeholders when their full quality versions are ready to be displayed.</p> CoilGlide <p></p><pre><code>ZoomableAsyncImage(\nmodifier = Modifier.fillMaxSize(),\nmodel = ImageRequest.Builder(LocalContext.current)\n.data(\"https://example.com/image.jpg\")\n.placeholderMemoryCacheKey(\u2026)\n.crossfade(1_000)\n.build(),\ncontentDescription = \u2026\n)\n</code></pre> More details about <code>placeholderMemoryCacheKey()</code> can be found on Coil's website.  <p></p><pre><code>ZoomableGlideImage(\nmodifier = Modifier.fillMaxSize(),\nmodel = \"https://example.com/image.jpg\",\ncontentDescription = \u2026\n) {\nit.thumbnail(\u2026)   // or placeholder()\n.transition(withCrossFade(1_000)),\n}\n</code></pre> More details about <code>thumbnail()</code> can be found on Glide's website."},{"location":"zoomableimage/#content-alignment","title":"Content alignment","text":"<code>Alignment.TopCenter</code> <code>Alignment.BottomCenter</code> <p>When images are zoomed, they're scaled with respect to their <code>alignment</code> until they're large enough to fill all available space. After that, they're scaled uniformly. The default <code>alignment</code> is <code>Alignment.Center</code>.</p> CoilGlide <pre><code>ZoomableAsyncImage(\nmodifier = Modifier.fillMaxSize(),\nmodel = \"https://example.com/image.jpg\",\nalignment = Alignment.TopCenter\n)\n</code></pre> <pre><code>ZoomableGlideImage(\nmodifier = Modifier.fillMaxSize(),\nmodel = \"https://example.com/image.jpg\",\nalignment = Alignment.TopCenter\n)\n</code></pre>"},{"location":"zoomableimage/#content-scale","title":"Content scale","text":"<code>ContentScale.Inside</code> <code>ContentScale.Crop</code> <p>Images are scaled using <code>ContentScale.Fit</code> by default, but can be customized. A visual guide of all possible values can be found here.</p> <p>Unlike <code>Image()</code>, <code>ZoomableImage</code> can pan images even when they're cropped. This can be useful for applications like wallpaper apps that may want to use <code>ContentScale.Crop</code> to ensure that images always fill the screen.</p> CoilGlide <pre><code>ZoomableAsyncImage(\nmodifier = Modifier.fillMaxSize(),\nmodel = \"https://example.com/image.jpg\",\ncontentScale = ContentScale.Crop\n)\n</code></pre> <pre><code>ZoomableGlideImage(\nmodifier = Modifier.fillMaxSize(),\nmodel = \"https://example.com/image.jpg\",\ncontentScale = ContentScale.Crop\n)\n</code></pre> <p>Warning</p> <p>Placeholders are visually incompatible with <code>ContentScale.Inside</code>.</p>"},{"location":"zoomableimage/#click-listeners","title":"Click listeners","text":"<p>For detecting double clicks, <code>ZoomableImage</code> consumes all tap gestures making it incompatible with <code>Modifier.clickable()</code> and <code>Modifier.combinedClickable()</code>. As an alternative, its <code>onClick</code> and <code>onLongClick</code> parameters can be used.</p> CoilGlide <pre><code>ZoomableAsyncImage(\nmodifier = Modifier.clickable { error(\"This will not work\") },\nmodel = \"https://example.com/image.jpg\",\nonClick = { \u2026 },\nonLongClick = { \u2026 },\n)\n</code></pre> <pre><code>ZoomableGlideImage(\nmodifier = Modifier.clickable { error(\"This will not work\") },\nmodel = \"https://example.com/image.jpg\",\nonClick = { \u2026 },\nonLongClick = { \u2026 },\n)\n</code></pre> <p>The default behavior of toggling between minimum and maximum zoom levels on double-clicks can be overridden by using the <code>onDoubleClick</code> parameter:</p> Coil\" hl_lines=\"3Glide <pre><code>ZoomableAsyncImage(\nmodel = \"https://example.com/image.jpg\",\nonDoubleClick = { state, centroid -&gt; \u2026 },\n)\n</code></pre> <pre><code>ZoomableGlideImage(\nmodel = \"https://example.com/image.jpg\",\nonDoubleClick = { state, centroid -&gt; \u2026 },\n)\n</code></pre>"},{"location":"zoomableimage/#keyboard-shortcuts","title":"Keyboard shortcuts","text":"<p><code>ZoomableImage()</code> can observe keyboard and mouse shortcuts for panning and zooming when it is focused, either by the user or using a <code>FocusRequester</code>:</p> <pre><code>val focusRequester = remember { FocusRequester() }\nLaunchedEffect(Unit) {\n// Automatically request focus when the image is displayed. This assumes there \n// is only one zoomable image present in the hierarchy. If you're displaying \n// multiple images in a pager, apply this only for the active page.  \nfocusRequester.requestFocus()\n}\n</code></pre> CoilGlide <pre><code>ZoomableAsyncImage(\nmodifier = Modifier.focusRequester(focusRequester),\nmodel = \"https://example.com/image.jpg\",\n)\n</code></pre> <pre><code>ZoomableGlideImage(\nmodifier = Modifier.focusRequester(focusRequester),\nmodel = \"https://example.com/image.jpg\",\n)\n</code></pre> <p>By default, the following shortcuts are recognized. These can be customized (or disabled) by passing a custom <code>HardwareShortcutsSpec</code> to <code>rememberZoomableState()</code>.</p> Android Zoom in <code>Control</code> + <code>=</code> Zoom out <code>Control</code> + <code>-</code> Pan Arrow keys Extra pan <code>Alt</code> + arrow keys"},{"location":"zoomableimage/#sharing-hoisted-state","title":"Sharing hoisted state","text":"<p>For handling zoom gestures, <code>Zoomablemage</code> uses <code>Modifier.zoomable()</code> underneath. If your app displays different kinds of media, it is recommended to hoist the <code>ZoomableState</code> outside so that it can be shared with all zoomable composables:</p> CoilGlide <pre><code>val zoomableState = rememberZoomableState()\nwhen (media) {\nis Image -&gt; {\nZoomableAsyncImage(\nmodel = media.imageUrl,\nstate = rememberZoomableImageState(zoomableState),\n)\n}\nis Video -&gt; {\nZoomableVideoPlayer(\nmodel = media.videoUrl,\nstate = rememberZoomableExoState(zoomableState),\n)\n}\n}\n</code></pre> <pre><code>val zoomableState = rememberZoomableState()\nwhen (media) {\nis Image -&gt; {\nZoomableGlideImage(\nmodel = media.imageUrl,\nstate = rememberZoomableImageState(zoomableState),\n)\n}\nis Video -&gt; {\nZoomableVideoPlayer(\nmodel = media.videoUrl,\nstate = rememberZoomableExoState(zoomableState),\n)\n}\n}\n</code></pre>"},{"location":"zoomableimage/custom-image-loaders/","title":"Custom image loaders","text":""},{"location":"zoomableimage/custom-image-loaders/#custom-image-loaders","title":"Custom image loaders","text":"<p>In its essence, <code>ZoomableImage</code> is simply an abstraction over an image loading library. If your preferred library isn't supported by <code>telephoto</code> out of the box, you can create your own by implementing <code>ZoomableImageSource</code>.</p> <pre><code>@Composable\nfun ZoomablePicassoImage(\nmodel: Any?,\ncontentDescription: String?,\n) {\nZoomableImage(\nimage = ZoomableImageSource.picasso(model),\ncontentDescription = contentDescription,\n)\n}\n@Composable\nprivate fun ZoomableImageSource.Companion.picasso(\nmodel: Any?,\npicasso: Picasso = Picasso\n.Builder(LocalContext.current)\n.build(),\n): ZoomableImageSource {\nreturn remember(model, picasso) {\nTODO(\"See ZoomableImageSource.coil() or glide() for an example.\")\n}\n}\n</code></pre> <p><code>ZoomableImageSource.picasso()</code> will be responsible for loading images and determining whether they can be displayed as-is or should be presented in a sub-sampled image viewer to prevent OOM errors. Here are two examples:</p> <ul> <li>CoilImageSource</li> <li>GlideImageSource</li> </ul>"},{"location":"zoomableimage/recipes/","title":"Recipes","text":""},{"location":"zoomableimage/recipes/#recipes","title":"Recipes","text":""},{"location":"zoomableimage/recipes/#modifierzoomable","title":"Modifier.zoomable()","text":"<ul> <li>Observing pan &amp; zoom</li> <li>Controlling pan &amp; zoom</li> <li>Resetting zoom</li> </ul>"},{"location":"zoomableimage/recipes/#setting-zoom-limits","title":"Setting zoom limits","text":"CoilGlide <pre><code>val zoomableState = rememberZoomableState(\nzoomSpec = ZoomSpec(maxZoomFactor = 4f)\n)\nZoomableAsyncImage(\nstate = rememberZoomableImageState(zoomableState),\nmodel = \"https://example.com/image.jpg\",\ncontentDescription = \u2026,\n)\n</code></pre> <pre><code>val zoomableState = rememberZoomableState(\nzoomSpec = ZoomSpec(maxZoomFactor = 4f)\n)\nZoomableGlideImage(\nstate = rememberZoomableImageState(zoomableState),\nmodel = \"https://example.com/image.jpg\",\ncontentDescription = \u2026,\n)\n</code></pre>"},{"location":"zoomableimage/recipes/#observing-image-loads","title":"Observing image loads","text":"<pre><code>val imageState = rememberZoomableImageState()\n// Whether the full quality image is loaded. This will be false for placeholders\n// or thumbnails, in which case isPlaceholderDisplayed can be used instead.\nval showLoadingIndicator = imageState.isImageDisplayed\nAnimatedVisibility(visible = showLoadingIndicator) {\nCircularProgressIndicator()    }\n</code></pre>"},{"location":"zoomableimage/recipes/#grabbing-downloaded-images","title":"Grabbing downloaded images","text":"<p>Low resolution drawables can be accessed by using request listeners. These images are down-sampled by your image loading library to fit in memory and are suitable for simple use-cases such as color extraction.</p> CoilGlide <pre><code>ZoomableAsyncImage(\nmodel = ImageRequest.Builder(LocalContext.current)\n.data(\"https://example.com/image.jpg\")\n.listener(onSuccess = { _, result -&gt;\n// TODO: do something with result.drawable.\n})\n.build(),\ncontentDescription = \u2026\n)\n</code></pre> <pre><code>ZoomableGlideImage(\nmodel = \"https://example.com/image.jpg\",\ncontentDescription = \u2026\n) {\nit.addListener(object : RequestListener&lt;Drawable&gt; {\noverride fun onResourceReady(resource: Drawable, \u2026): Boolean {\n// TODO: do something with resource.\n}\n})\n}\n</code></pre> <p>Full resolutions must be obtained as files because <code>ZoomableImage</code> streams them directly from disk. The easiest way to do this is to load them again from cache.</p> CoilGlide <p></p><pre><code>val state = rememberZoomableImageState()\nZoomableAsyncImage(\nmodel = imageUrl,\nstate = state,\ncontentDescription = \u2026,\n)\nif (state.isImageDisplayed) {\nButton(onClick = { downloadImage(context, imageUrl) }) {\nText(\"Download image\")\n}\n}\n</code></pre> <pre><code>suspend fun downloadImage(context: Context, imageUrl: HttpUrl) {\nval result = context.imageLoader.execute(\nImageRequest.Builder(context)\n.data(imageUrl)\n.build()\n)\nif (result is SuccessResult) {\nval cacheKey = result.diskCacheKey ?: error(\"image wasn't saved to disk\")\nval diskCache = context.imageLoader.diskCache!!\ndiskCache.openSnapshot(cacheKey)!!.use { // TODO: copy to Downloads directory.           \n}\n}\n}\n</code></pre> <p></p><pre><code>val state = rememberZoomableImageState()\nZoomableGlideImage(\nmodel = imageUrl,\nstate = state,\ncontentDescription = \u2026,\n)\nif (state.isImageDisplayed) {\nButton(onClick = { downloadImage(context, imageUrl) }) {\nText(\"Download image\")\n}\n}\n</code></pre> <pre><code>fun downloadImage(context: Context, imageUrl: Uri) {\nGlide.with(context)\n.download(imageUrl)\n.into(object : CustomTarget&lt;File&gt;() {\noverride fun onResourceReady(resource: File, \u2026) {\n// TODO: copy file to Downloads directory.\n}\noverride fun onLoadCleared(placeholder: Drawable?) = Unit\n)\n}\n</code></pre>"},{"location":"zoomableimage/sub-sampling/","title":"Sub-sampling","text":""},{"location":"zoomableimage/sub-sampling/#sub-sampling","title":"Sub-sampling","text":"<p>For displaying large images that may not fit into memory, <code>ZoomableImage</code> automatically divides them into tiles so that they can be loaded lazily.</p> <p>If <code>ZoomableImage</code> can't be used or if sub-sampling of images is always desired, you could potentially use <code>SubSamplingImage()</code> directly.</p> <pre><code>implementation(\"me.saket.telephoto:sub-sampling-image:0.13.0\")\n</code></pre> <pre><code>val zoomableState = rememberZoomableState()\nval imageState = rememberSubSamplingImageState(\nzoomableState = zoomableState,\nimageSource = SubSamplingImageSource.asset(\"fox.jpg\")\n)\nSubSamplingImage(\nmodifier = Modifier\n.fillMaxSize()\n.zoomable(zoomableState),\nstate = imageState,\ncontentDescription = \u2026,\n)\n</code></pre> <p><code>SubSamplingImage()</code> is an adaptation of the excellent subsampling-scale-image-view by Dave Morrissey.</p>"}]}